import { EventEmitter } from 'events';

interface GeminiRequest {
  contents: Array<{
    parts: Array<{
      text: string;
    }>;
    role: 'user' | 'model';
  }>;
  generationConfig: {
    temperature: number;
    maxOutputTokens: number;
    topP?: number;
    topK?: number;
  };
  safetySettings?: Array<{
    category: string;
    threshold: string;
  }>;
}

interface GeminiResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
      role: string;
    };
    finishReason: string;
    index: number;
    safetyRatings: Array<{
      category: string;
      probability: string;
    }>;
  }>;
  usageMetadata: {
    promptTokenCount: number;
    candidatesTokenCount: number;
    totalTokenCount: number;
  };
}

class GeminiProvider extends EventEmitter {
  private apiKey: string;
  private baseUrl: string;
  private model: string;

  constructor(apiKey: string, model = 'gemini-2.0-flash-exp') {
    super();
    this.apiKey = apiKey;
    this.model = model;
    this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  }

  public async generateContent(
    messages: Array<{ role: 'system' | 'user' | 'assistant'; content: string }>,
    options: {
      temperature?: number;
      maxTokens?: number;
      topP?: number;
      topK?: number;
    } = {}
  ): Promise<{
    content: string;
    usage: {
      promptTokens: number;
      completionTokens: number;
      totalTokens: number;
    };
    model: string;
    provider: string;
  }> {
    try {
      const contents = this.convertMessagesToGeminiFormat(messages);
      
      const request: GeminiRequest = {
        contents,
        generationConfig: {
          temperature: options.temperature || 0.7,
          maxOutputTokens: options.maxTokens || 500,
          topP: options.topP || 0.8,
          topK: options.topK || 40
        },
        safetySettings: [
          {
            category: 'HARM_CATEGORY_HARASSMENT',
            threshold: 'BLOCK_MEDIUM_AND_ABOVE'
          },
          {
            category: 'HARM_CATEGORY_HATE_SPEECH',
            threshold: 'BLOCK_MEDIUM_AND_ABOVE'
          },
          {
            category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
            threshold: 'BLOCK_MEDIUM_AND_ABOVE'
          },
          {
            category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
            threshold: 'BLOCK_MEDIUM_AND_ABOVE'
          }
        ]
      };

      const url = `${this.baseUrl}/models/${this.model}:generateContent?key=${this.apiKey}`;
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(request)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
      }

      const data: GeminiResponse = await response.json();
      
      if (!data.candidates || data.candidates.length === 0) {
        throw new Error('No response generated by Gemini');
      }

      const candidate = data.candidates[0];
      
      if (candidate.finishReason === 'SAFETY') {
        throw new Error('Response blocked by safety filters');
      }

      const content = candidate.content.parts[0]?.text || '';
      
      return {
        content,
        usage: {
          promptTokens: data.usageMetadata.promptTokenCount,
          completionTokens: data.usageMetadata.candidatesTokenCount,
          totalTokens: data.usageMetadata.totalTokenCount
        },
        model: this.model,
        provider: 'gemini'
      };

    } catch (error) {
      console.error('Gemini generation error:', error);
      throw error;
    }
  }

  private convertMessagesToGeminiFormat(
    messages: Array<{ role: 'system' | 'user' | 'assistant'; content: string }>
  ): Array<{ parts: Array<{ text: string }>; role: 'user' | 'model' }> {
    const contents: Array<{ parts: Array<{ text: string }>; role: 'user' | 'model' }> = [];
    
    // Gemini doesn't have a system role, so we'll combine system message with first user message
    let systemMessage = '';
    const filteredMessages = messages.filter(msg => {
      if (msg.role === 'system') {
        systemMessage = msg.content;
        return false;
      }
      return true;
    });

    for (let i = 0; i < filteredMessages.length; i++) {
      const message = filteredMessages[i];
      
      let content = message.content;
      
      // Add system message to first user message
      if (i === 0 && message.role === 'user' && systemMessage) {
        content = `${systemMessage}\n\nUsuário: ${content}`;
      }

      contents.push({
        parts: [{ text: content }],
        role: message.role === 'assistant' ? 'model' : 'user'
      });
    }

    return contents;
  }

  public async testConnection(): Promise<boolean> {
    try {
      const testMessages = [
        { role: 'user' as const, content: 'Teste de conexão' }
      ];
      
      await this.generateContent(testMessages, { maxTokens: 10 });
      return true;
    } catch (error) {
      console.error('Gemini connection test failed:', error);
      return false;
    }
  }

  public getModel(): string {
    return this.model;
  }

  public setModel(model: string): void {
    this.model = model;
  }

  public getAvailableModels(): string[] {
    return [
      'gemini-2.0-flash-exp',
      'gemini-1.5-pro',
      'gemini-1.5-flash',
      'gemini-pro'
    ];
  }
}

export { GeminiProvider };